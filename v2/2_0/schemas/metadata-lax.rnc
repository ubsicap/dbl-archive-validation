# metadata.rnc
# Generated from templates

default namespace = ""
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

start = dblMetadataElement

dblMetadataElement = (translationMetadata | expressionMetadata | translationAndExpressionMetadata)

translationMetadata = textTranslationMetadata | audioTranslationMetadata | videoTranslationMetadata

expressionMetadata = textExpressionMetadata | audioExpressionMetadata | printExpressionMetadata | videoExpressionMetadata | brailleExpressionMetadata

translationAndExpressionMetadata = textTranslationAndExpressionMetadata | audioTranslationAndExpressionMetadata | videoTranslationAndExpressionMetadata

textTranslationMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationCommonElements &
  fullLanguageElement &
  textTranslationTypeElement &
  textFormatElement
}

audioTranslationMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationCommonElements &
  shortLanguageElement &
  audioTranslationTypeElement &
  audioFormatElement
}

videoTranslationMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationCommonElements &
  shortLanguageElement &
  videoTranslationTypeElement &
  videoFormatElement
}

textExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  textExpressionTypeElement &
  textFormatElement
}

printExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  printExpressionTypeElement &
  printFormatElement
}

audioExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  audioExpressionTypeElement &
  audioFormatElement
}

videoExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  videoExpressionTypeElement &
  videoFormatElement
}

brailleExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  brailleExpressionTypeElement &
  brailleFormatElement
}

textTranslationAndExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationAndExpressionCommonElements &
  fullLanguageElement &
  textTranslationAndExpressionTypeElement &
  textFormatElement
}

audioTranslationAndExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationAndExpressionCommonElements &
  fullLanguageElement &
  audioTranslationAndExpressionTypeElement &
  audioFormatElement
}

videoTranslationAndExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationAndExpressionCommonElements &
  fullLanguageElement &
  videoTranslationAndExpressionTypeElement &
  videoFormatElement
}

translationCommonElements = (
  commonElements &
  translationManifestElement &
  translationSourceElement
)

expressionCommonElements = (
  commonElements &
  promotionElement &
  nonTranslationManifestElement &
  publicationsElement &
  translationSourceElement?
)

translationAndExpressionCommonElements = (
  commonElements &
  promotionElement &
  translationManifestElement &
  publicationsElement &
  translationSourceElement
)

commonElements = (
  identificationElement &
  relationshipsElement &
  agenciesElement &
  countryElement &
  namesElement &
  copyrightElement &
  archiveStatusElement
)

dblMetadataCommonAtts = (
  attribute version { "2.0" } &
  attribute id { bundleIdString } &
  attribute revision { revisionValue } &
  attribute lax { xsd:boolean }?
)

# metadata text (lax)

bundleIdString = text

revisionValue = text

# generic text (lax)

nonEmptyString = text

lenGe1String = text

lenGe2String = text

lenGe2Le255String = text

lenLe255String = text

anyURI = text

# identification

identificationElement =
  element identification {
    element name { lenGe2String } &
    element nameLocal { lenGe2String }? &
    element abbreviation { abbreviationString }? &
    element abbreviationLocal { localAbbreviationString }? &
    element description { lenGe2String } &
    element descriptionLocal { lenGe2String }? &
    element scope { scopeEnum } &
    canonSpecElement? &

    element dateCompleted { dateCompletedValue }? &
    (gbcSystemId | ptSystemId | reapSystemId | biblicaSystemId | tmsSystemId | ptregSystemId)* &
    element bundleProducer { lenGe2String }
    }

gbcSystemId =
  element systemId {
    attribute type { "gbc" },
    gbcElements
  }

gbcElements =
  element id {
    gbcId
  }

ptregSystemId =
  element systemId {
    attribute type { "ptreg" },
    ptregElements
 }

tmsSystemId =
  element systemId {
    attribute type { "tms" },
    tmsElements
  }

tmsElements =
  element id {
    tmsId
  }

ptSystemId =
  element systemId {
    attribute type { "paratext" },
    ptElements
  }

ptElements =
  element name { lenGe2String } &
  element fullName { lenGe2String } &
  element csetId { lenGe2String } &
  element id { ptId }

ptregElements =
  element id { ptregId }

reapSystemId =
  element systemId {
    attribute type { "reap" },
    reapElements
  }

reapElements =
  element id { reapId }

biblicaSystemId =
  element systemId {
    attribute type { "biblica" },
    biblicaElements
  }

biblicaElements =
  element id { biblicaId }

# canon

canonSpecElement =
    element canonSpec {
        attribute type { canonTypes },
        canonComponent+
    }

canonComponent =
    element component { canonComponentEnum }

# canon (lax)

canonTypes = text

canonComponentEnum = text

# identification text (lax)

abbreviationString = text

localAbbreviationString = text

biblicaId = text

gbcId = text

tmsId = text

ptId = text

ptregId = text

reapId = text

dateCompletedValue = text

scopeEnum = text

# relationships

relationshipsElement =
  element relationships {
    (sourceRelationElement | expressionRelationElement)*
  }

sourceRelationElement =
  element relation {
    attribute relationType { "source" },
    attribute type { "text" | "audio" },
    attribute id { bundleIdString },
    attribute revision { xsd:integer }
  }

expressionRelationElement =
  element relation {
    attribute relationType { "expression" },
    attribute type { "audio" | "print" },
    attribute id { bundleIdString },
    attribute revision { xsd:integer }
  }

# agencies

agenciesElement =
  element agencies {
    rightsHolderElement+ &
    rightsAdminElement? &
    contributorElement+ &
    etenPartnerElement?
  }

rightsHolderElement =
  element rightsHolder {
    element abbr { lenGe2String } &
    element url { anyURI } &
    element local { lenGe2String } &
    element uid { agenciesUID } &
    element name { lenGe2String }
  }

rightsAdminElement =
  element rightsAdmin {
    element url { anyURI }? &
    element uid { agenciesUID } &
    element name { lenGe2String }
  }

contributorElement =
  element contributor {
    element content { xsd:boolean } &
    element publication { xsd:boolean }? &
    element management { xsd:boolean }? &
    element finance { xsd:boolean }? &
    element qa { xsd:boolean }? &
    element uid { agenciesUID } &
    element name { lenGe2String }
    }

etenPartnerElement =
  element etenPartner {
    element uid { lenGe2String }? &
    element name { lenGe2String }?
  }

# agencies text (lax)

agenciesUID = text

# language

fullLanguageElement =
  element language {
    commonLanguageElements &
    element script { iso15924String } &
    element scriptDirection { languageScriptDirectionEnum }
  }

shortLanguageElement =
  element language {
    commonLanguageElements &
    element script { iso15924String }? &
    element scriptDirection { languageScriptDirectionEnum }?
    }

commonLanguageElements = (
    element iso { languageIsoString } &
    element name { lenGe2String } &
    element nameLocal { lenGe2String }? &
    element ldml { ldmlString }? &
    element rod { rodString }? &
    element numerals { numeralSystemEnum }?
)

# language text (lax)

languageIsoString = text

ldmlString = text

iso15924String = text

rodString = text

languageScriptDirectionEnum = text

numeralSystemEnum = text

# country

countriesElement = element countries { countryElement+ }

countryElement = element country {
  element iso { countryIsoString } &
  element name { lenGe2String } &
  element nameLocal { lenGe2String }?
}

# country text (lax)

countryIsoString = text

# type

textTranslationTypeElement =
  element type {
    element medium { "text" } &
    element hasCharacters { "true" } &
    element isTranslation { "true" } &
    element isExpression { "false" } &
    element isConfidential { xsd:boolean } &
    commonTextTranslationTypeElements
}

audioTranslationTypeElement =
  element type {
    element medium { "audio" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "false" } &
    element isConfidential { xsd:boolean } &
    commonAudioTranslationTypeElements
}

videoTranslationTypeElement =
  element type {
    element medium { "video" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "false" } &
    element isConfidential { xsd:boolean } &
    commonVideoTranslationTypeElements
}

textExpressionTypeElement =
  element type {
    element medium { "text" } &
    element hasCharacters { "true" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonTextExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

printExpressionTypeElement =
  element type {
    element medium { "print" } &
    element hasCharacters { "true" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

audioExpressionTypeElement =
  element type {
    element medium { "audio" } &
    element hasCharacters { "false" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonAudioExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

videoExpressionTypeElement =
  element type {
    element medium { "video" } &
    element hasCharacters { "false" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonVideoExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

brailleExpressionTypeElement =
  element type {
    element medium { "braille" } &
    element hasCharacters { "true" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    element isConfidential { xsd:boolean }
}

textTranslationAndExpressionTypeElement =
  element type {
    element medium { "text" } &
    element hasCharacters { "true" } &
    element isTranslation { "true" } &
    element isExpression { "true" } &
    commonTextTranslationTypeElements &
    commonTextExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

audioTranslationAndExpressionTypeElement =
  element type {
    element medium { "audio" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "true" } &
    commonAudioTranslationTypeElements &
    commonAudioExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

videoTranslationAndExpressionTypeElement =
  element type {
    element medium { "video" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "true" } &
    commonVideoTranslationTypeElements &
    commonVideoExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

commonTextTranslationTypeElements = (
  commonTranslationTypeElements
)

commonAudioTranslationTypeElements = (
  commonTranslationTypeElements
)

commonVideoTranslationTypeElements = (
  commonTranslationTypeElements
)

commonTextExpressionTypeElements = (
  commonExpressionTypeElements
)

commonAudioExpressionTypeElements = (
  element dramatization { audioTypeDramatizationEnum } &
  commonExpressionTypeElements
)

commonVideoExpressionTypeElements = (
  commonExpressionTypeElements
)

commonTranslationTypeElements = (
  commonTypeElements &
  element translationType { translationTypeEnum } &
  element audience { translationLevelEnum }
)

commonExpressionTypeElements = (
  commonTypeElements
)

commonTypeElements = (
  empty
)

# type text (lax)

audioTypeDramatizationEnum = text

translationTypeEnum = text

translationLevelEnum = text

# format

textFormatElement =
  element format {
    element versedParagraphs { xsd:boolean }
  }

audioFormatElement = # DCMI: format
  element format { audioSubelements}

audioSubelements =
    element compression { audioCompressionEnum }? &
    element trackConfiguration { audioTrackEnum }? &
    element bitRate { xsd:integer }? &
    element bitDepth { xsd:integer }? &
    element samplingRate { xsd:integer }?

printFormatElement =
  element format {
    element pod { xsd:boolean } &
    element width { measurementString } &
    element height { measurementString } &
    element scale { percentageString } &
    element orientation { printOrientationEnum } &
    element color { printColorEnum } &
    element fonts { printFormatFontElement* }
  }

printFormatFontElement =
  element font {
    attribute type { printFontEnum },
    text
  }

videoFormatElement =
  element format {
    element container {"MP4"} &
      videoFormatVideoStream &
      videoFormatAudioStream? &
      videoFormatSubtitleStream?
    }

videoFormatVideoStream =
  element videoStream {
      element codec { xsd:string } &
      element bitRate { xsd:positiveInteger } &
      element frameRate { xsd:decimal } &
      element screenResolution { screenResolution }
  }

videoFormatAudioStream =
  element audioStream { audioSubelements }

videoFormatSubtitleStream = element subtitleStream { empty }

brailleFormatElement =
  element format {
    element contracted { xsd:boolean } &
    element libLouisConfig { xsd:string }
  }

# format text (lax)

measurementString = text

percentageString = text

screenResolution = text

audioCompressionEnum = text

audioTrackEnum = text

printOrientationEnum = text

printColorEnum = text

printFontEnum = text

# names

namesElement =
  element names { namesName* }

namesName =
  element name {
    attribute id { nameIdString } &
    element long { lenGe2Le255String }? &
    element short { lenGe2Le255String } &
    element abbr { lenGe2Le255String }?
  }

# name text (lax)

nameIdString = text

# manifest

nonTranslationManifestElement =
  element manifest { (nonTranslationManifestContainer | nonTranslationManifestResource)+ }

translationManifestElement =
  element manifest { (translationManifestContainer | translationManifestResource)+ }

nonTranslationManifestContainer =
  element container {
    attribute uri { anyURI },
    (nonTranslationManifestContainer | nonTranslationManifestResource)+
  }

nonTranslationManifestResource =
  element resource {
    commonManifestResourceAtts
  }

translationManifestContainer =
  element container {
    attribute uri { anyURI },
    (translationManifestContainer | translationManifestResource)+
  }

translationManifestResource =
  element resource {
    commonManifestResourceAtts &
    attribute progress { xsd:positiveInteger { maxInclusive = "999" } }?
  }

commonManifestResourceAtts = (
  attribute uri { anyURI},
  attribute size { xsd:integer },
  attribute checksum { s3Checksum }?,
  attribute mimeType { mimeTypeString }
)

# manifest text (lax)

s3Checksum = text

mimeTypeString = text

# source

translationSourceElement =
  element source {
    empty |
    ( element canonicalContent { canonicalContentBook+} & (sourceStructureDivision | sourceStructureContent)+ )
  }

sourceStructureDivision =
  element division {
    attribute name {nameIdString},
    attribute role {roleId}?,
    (sourceStructureDivision | sourceStructureContent)+
  }

sourceStructureContent =
  element content {
    attribute name {nameIdString} &
    attribute src {srcPathString} &
    attribute role {roleId}?
  }

# source text (lax)

srcPathString = text

# publications

publicationsElement = # DCMI: tableOfContents
  element publications { publicationElement* }

publicationElement =
  element publication {
  attribute id { publicationId },
  attribute default { xsd:boolean }?,
  publicationChildElements
  }

publicationChildElements = (
  element name { lenGe2String }? &
  element nameLocal { lenGe2String }? &
  element abbreviation { lenGe2String }? &
  element abbreviationLocal { lenGe2String }? &
  element description { lenGe2String }? &
  element descriptionLocal { lenGe2String }? &
  publicationCountriesElement? &
  element scope { scopeEnum }? &
  canonSpecElement? &
  element canonicalContent { canonicalContentBook+} &
  element structure { (publicationStructureDivision | publicationStructureContent)+ }
)

publicationCountriesElement = element countries { countryElement+ }

canonicalContentBook =
  element book {
    attribute code { canonicalBookIdEnum }
  }

publicationStructureDivision =
  element division {
    attribute name {nameIdString},
    attribute role {roleId}?,
    (publicationStructureDivision | publicationStructureContent)+
  }

publicationStructureContent =
  element content {
    attribute name {nameIdString} &
    attribute src {srcPathString} &
    attribute role {roleId}?
  }

# publications text

roleId = text

canonicalBookIdEnum = text

nonCanonicalBookIdEnum = text

publicationId = text

# copyright

copyrightElement =
  element copyright {
    copyrightFullStatementElement &
    copyrightShortStatementElement?
  }

copyrightFullStatementElement =
  element fullStatement { statementContent+ }

copyrightShortStatementElement =
  element shortStatement { statementContent+ }

statementContent = htmlStatementContent | plainStatementContent

htmlStatementContent =
  element statementContent {
    attribute contentType { "xhtml" },
    simplifiedHtml+
  }

plainStatementContent =
  element statementContent {
    attribute contentType { "plain" },
    text
  }

# html

simplifiedHtml = shBlockElement+

shBlockElement = (
    shP |
    shH1 |
    shH2 |
    shH3 |
    shUl |
    shOl |
    shBlockquote
)

shP = element p { nonEmptyString* & shCharMarkup* }

shH1 = element h1 { nonEmptyString* & shCharMarkup* }

shH2 = element h2 { nonEmptyString* & shCharMarkup* }

shH3 = element h3 { nonEmptyString* & shCharMarkup* }

shOl = element ol { shLi+ }

shUl = element ul { shLi+ }

shLi = element li { nonEmptyString* & shCharMarkup* }

shBlockquote = element blockquote { shBlockElement+ }

shCharMarkup = (
  shA |
  shImg |
  shBr |
  shStrong |
  shB |
  shEm |
  shI
)

shA =
  element a {
    attribute href { anyURI },
    (nonEmptyString* & shCharMarkup* )
  }

shImg =
  element img {
    attribute src { anyURI },
    attribute alt { lenGe1String }
  }

shBr = element br { empty }

shStrong = element strong { nonEmptyString* & shCharMarkup* }

shB = element b { nonEmptyString* & shCharMarkup* }

shEm = element em { nonEmptyString* & shCharMarkup* }

shI = element i { nonEmptyString* & shCharMarkup* }

# promotion

promotionElement =
  element promotion {
    element promoVersionInfo {
      attribute contentType { "xhtml" },
      simplifiedHtml+
    }
  }

# archive_status

archiveStatusElement =
  element archiveStatus {
    element bundleCreatorName {lenGe2String}? &
    element archivistName { lenGe2String } &
    element dateArchived { xsd:dateTime | "null" } &
    element dateUpdated { xsd:dateTime | "null" } &
    element comments { lenLe255String }
  }

