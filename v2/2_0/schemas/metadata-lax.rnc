# metadata.rnc
# Generated from templates

default namespace = ""
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

start = dblMetadataElement

dblMetadataElement = (translationMetadata | expressionMetadata | translationAndExpressionMetadata)

translationMetadata = textTranslationMetadata | audioTranslationMetadata | videoTranslationMetadata

expressionMetadata = textExpressionMetadata | audioExpressionMetadata | printExpressionMetadata | videoExpressionMetadata | brailleExpressionMetadata

translationAndExpressionMetadata = textTranslationAndExpressionMetadata | audioTranslationAndExpressionMetadata | videoTranslationAndExpressionMetadata

textTranslationMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationCommonElements &
  fullLanguageElement &
  textTranslationTypeElement &
  textFormatElement
}

audioTranslationMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationCommonElements &
  shortLanguageElement &
  audioTranslationTypeElement &
  audioFormatElement
}

videoTranslationMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationCommonElements &
  shortLanguageElement &
  videoTranslationTypeElement &
  videoFormatElement
}

textExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  textExpressionTypeElement &
  textFormatElement
}

printExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  printExpressionTypeElement &
  printFormatElement
}

audioExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  audioExpressionTypeElement &
  audioFormatElement
}

videoExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  videoExpressionTypeElement &
  videoFormatElement
}

brailleExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  brailleExpressionTypeElement &
  brailleFormatElement
}

textTranslationAndExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationAndExpressionCommonElements &
  fullLanguageElement &
  textTranslationAndExpressionTypeElement &
  textFormatElement
}

audioTranslationAndExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationAndExpressionCommonElements &
  fullLanguageElement &
  audioTranslationAndExpressionTypeElement &
  audioFormatElement
}

videoTranslationAndExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  translationAndExpressionCommonElements &
  fullLanguageElement &
  videoTranslationAndExpressionTypeElement &
  videoFormatElement
}

translationCommonElements = (
  commonElements &
  translationManifestElement &
  translationSourceElement
)

expressionCommonElements = (
  commonElements &
  promotionElement &
  nonTranslationManifestElement &
  publicationsElement &
  translationSourceElement?
)

translationAndExpressionCommonElements = (
  commonElements &
  promotionElement &
  translationManifestElement &
  publicationsElement &
  translationSourceElement
)

commonElements = (
  identificationElement &
  relationshipsElement &
  agenciesElement &
  countryElement &
  namesElement &
  copyrightElement &
  archiveStatusElement
)

dblMetadataCommonAtts = (
  attribute version { "2.0" } &
  attribute id { bundleIdString } &
  attribute revision { xsd:integer | "null" }
)

# metadata text (lax)

bundleIdString = text

# generic text (lax)

nonEmptyString = text

lenGe1String = text

lenGe2String = text

lenGe2Le255String = text

lenLe255String = text

# identifaction

identificationElement =
  element identification {
    element name { lenGe2String } &
    element nameLocal { lenGe2String }? &
    element abbreviation { abbreviationString }? &
    element abbreviationLocal { localAbbreviationString }? &
    element description { lenGe2String } &
    element descriptionLocal { lenGe2String }? &
    element scope { scopeEnum } &
    canonSpecElement? &

    element dateCompleted {
      xsd:date |
      xsd:gYear |
      xsd:gYearMonth |
      xsd:dateTime
    }? &
    (gbcSystemId | ptSystemId | reapSystemId | biblicaSystemId | tmsSystemId | ptregSystemId)+ &
    element bundleProducer { lenGe2String }
    }

scopeEnum = (
    "Bible" |
    "Bible with Deuterocanon" |
    "Deuterocanon" |
    "New Testament" |
    "New Testament+" |
    "Old Testament" |
    "Old Testament + Deuterocanon" |
    "Old Testament+" |
    "Portions" |
    "Selections" |
    "Shorter Bible"
)

gbcSystemId =
  element systemId {
    attribute type { "gbc" },
    gbcElements
  }

gbcElements =
  element id {
    gbcId
  }

ptregSystemId =
  element systemId {
    attribute type { "ptreg" },
    ptregElements
 }

tmsSystemId =
  element systemId {
    attribute type { "tms" },
    tmsElements
  }

tmsElements =
  element id {
    tmsId
  }

ptSystemId =
  element systemId {
    attribute type { "paratext" },
    ptElements
  }

ptElements =
  element name { lenGe2String } &
  element fullName { lenGe2String } &
  element csetId { lenGe2String } &
  element id { ptId }

ptregElements =
  element id { ptregId }

reapSystemId =
  element systemId {
    attribute type { "reap" },
    reapElements
  }

reapElements =
  element id { reapId }

biblicaSystemId =
  element systemId {
    attribute type { "biblica" },
    biblicaElements
  }

biblicaElements =
  element id { biblicaId }

# canon

canonSpecElement =
    element canonSpec {
        attribute type { canonTypes },
        canonComponent+
    }

canonTypes = "DC" | "NT" | "OT, DC, NT" | "OT, NT, DC" | "OT, NT" | "OT+, NT" | "OT" | "OT+"

canonComponent =
    element component { canonComponentEnum }

canonComponentEnum =
    "armenianApostolicDC" |
    "armenianApostolicOT" |
    "armenianApostolicOT2" |
    "armenianClassicalOT" |
    "armenianNT" |
    "catholicAndAnglicanDC" |
    "catholicLxxDC" |
    "catholicLxxOT" |
    "catholicLxxSeparatedDC" |
    "catholicPlusLutheranDC" |
    "catholicVulgateDC" |
    "catholicVulgateOT" |
    "catholicVulgateSeparatedDC" |
    "czechKralickaDC" |
    "danishLutheranDC" |
    "ethiopianOrthodoxDC" |
    "ethiopianOrthodoxNT" |
    "ethiopianOrthodoxOT" |
    "ethiopianProtestantNT" |
    "ethiopianProtestantOT" |
    "georgianOrthodoxDC" |
    "georgianOrthodoxOT" |
    "georgianOrthodoxOT2" |
    "georgianSynodalDC" |
    "germanLutheranDC" |
    "greekOrthodoxDC" |
    "greekOrthodoxOT" |
    "kjvDC" |
    "kjvNonDC" |
    "lutheranNT" |
    "romanianOrthodoxDC" |
    "romanianOrthodoxOT" |
    "russianNT" |
    "russianOrthodoxDC" |
    "russianOrthodoxOT" |
    "russianProtestantOT" |
    "russianSynodalDC" |
    "syriacNT" |
    "syriacOT" |
    "tanakhOT" |
    "turkishInterconfessionalDC" |
    "vulgateCatholicBible" |
    "westernInterconfessionalDC" |
    "westernInterconfessionalDC2" |
    "westernNT" |
    "westernOT" |
    xsd:string { pattern = "X-[A-Za-z0-9][A-Za-z0-9\-]*" }

# identification text (lax)

abbreviationString = text

localAbbreviationString = text

biblicaId = text

gbcId = text

tmsId = text

ptId = text

ptregId = text

reapId = text

# relationships

relationshipsElement =
  element relationships {
    (sourceRelationElement | expressionRelationElement)*
  }

sourceRelationElement =
  element relation {
    attribute relationType { "source" },
    attribute type { "text" | "audio" },
    attribute id { bundleIdString },
    attribute revision { xsd:integer }
  }

expressionRelationElement =
  element relation {
    attribute relationType { "expression" },
    attribute type { "audio" | "print" },
    attribute id { bundleIdString },
    attribute revision { xsd:integer }
  }

# agencies

agenciesElement =
  element agencies {
    rightsHolderElement+ &
    rightsAdminElement? &
    contributorElement+ &
    etenPartnerElement?
  }

rightsHolderElement =
  element rightsHolder {
    element abbr { lenGe2String } &
    element url { xsd:anyURI } &
    element local { lenGe2String } &
    element uid { agenciesUID } &
    element name { lenGe2String }
  }

rightsAdminElement =
  element rightsAdmin {
    element url { xsd:anyURI }? &
    element uid { agenciesUID } &
    element name { lenGe2String }
  }

contributorElement =
  element contributor {
    element content { xsd:boolean } &
    element publication { xsd:boolean }? &
    element management { xsd:boolean }? &
    element finance { xsd:boolean }? &
    element qa { xsd:boolean }? &
    element uid { agenciesUID } &
    element name { lenGe2String }
    }

etenPartnerElement =
  element etenPartner {
    element uid { lenGe2String }? &
    element name { lenGe2String }?
  }

# agencies text (lax)

agenciesUID = text

# language

fullLanguageElement =
  element language {
    commonLanguageElements &
    element script { iso15924String } &
    element scriptDirection { languageScriptDirectionEnum }
  }

shortLanguageElement =
  element language {
    commonLanguageElements &
    element script { iso15924String }? &
    element scriptDirection { languageScriptDirectionEnum }?
    }

commonLanguageElements = (
    element iso { languageIsoString } &
    element name { lenGe2String } &
    element nameLocal { lenGe2String }? &
    element ldml { ldmlString }? &
    element rod { rodString }? &
    element numerals { numeralSystemEnum }?
)

# language text (lax)

languageIsoString = text

ldmlString = text

iso15924String = text

rodString = text

languageScriptDirectionEnum = text

numeralSystemEnum = text

# country

countriesElement = element countries { countryElement+ }

countryElement = element country {
  element iso { countryIsoString } &
  element name { lenGe2String } &
  element nameLocal { lenGe2String }?
}

# country text (lax)

countryIsoString = text

# type

textTranslationTypeElement =
  element type {
    element medium { "text" } &
    element hasCharacters { "true" } &
    element isTranslation { "true" } &
    element isExpression { "false" } &
    element isConfidential { xsd:boolean } &
    commonTextTranslationTypeElements
}

audioTranslationTypeElement =
  element type {
    element medium { "audio" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "false" } &
    element isConfidential { xsd:boolean } &
    commonAudioTranslationTypeElements
}

videoTranslationTypeElement =
  element type {
    element medium { "video" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "false" } &
    element isConfidential { xsd:boolean } &
    commonVideoTranslationTypeElements
}

textExpressionTypeElement =
  element type {
    element medium { "text" } &
    element hasCharacters { "true" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonTextExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

printExpressionTypeElement =
  element type {
    element medium { "print" } &
    element hasCharacters { "true" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

audioExpressionTypeElement =
  element type {
    element medium { "audio" } &
    element hasCharacters { "false" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonAudioExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

videoExpressionTypeElement =
  element type {
    element medium { "video" } &
    element hasCharacters { "false" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonVideoExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

brailleExpressionTypeElement =
  element type {
    element medium { "braille" } &
    element hasCharacters { "true" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    element isConfidential { xsd:boolean }
}

textTranslationAndExpressionTypeElement =
  element type {
    element medium { "text" } &
    element hasCharacters { "true" } &
    element isTranslation { "true" } &
    element isExpression { "true" } &
    commonTextTranslationTypeElements &
    commonTextExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

audioTranslationAndExpressionTypeElement =
  element type {
    element medium { "audio" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "true" } &
    commonAudioTranslationTypeElements &
    commonAudioExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

videoTranslationAndExpressionTypeElement =
  element type {
    element medium { "video" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "true" } &
    commonVideoTranslationTypeElements &
    commonVideoExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

commonTextTranslationTypeElements = (
  commonTranslationTypeElements
)

commonAudioTranslationTypeElements = (
  commonTranslationTypeElements
)

commonVideoTranslationTypeElements = (
  commonTranslationTypeElements
)

commonTextExpressionTypeElements = (
  commonExpressionTypeElements
)

commonAudioExpressionTypeElements = (
  element dramatization {
    "Dramatized" |
    "Non-Dramatized" |
    "Single-Voice"
  } &
  commonExpressionTypeElements
)

commonVideoExpressionTypeElements = (
  commonExpressionTypeElements
)

commonTranslationTypeElements = (
  commonTypeElements &
  element translationType { translationTypeEnum } &
  element audience { translationLevelEnum }
)

commonExpressionTypeElements = (
  commonTypeElements
)

commonTypeElements = (
  empty
)

translationTypeEnum = (
  "First" |
  "New" |
  "Revision"
)

translationLevelEnum = (
  "Basic" |
  "Common" |
  "Common - Literary" |
  "Literary" |
  "Liturgical"
)

# format

textFormatElement =
  element format {
    element versedParagraphs { xsd:boolean }
  }

audioFormatElement = # DCMI: format
  element format { audioSubelements}

audioSubelements =
    element compression { audioCompressionEnum }? &
    element trackConfiguration { audioTrackEnum }? &
    element bitRate { xsd:integer }? &
    element bitDepth { xsd:integer }? &
    element samplingRate { xsd:integer }?

audioCompressionEnum = (
  "MP3"  |
  "FLAC" |
  "WAV" |
  "AAC"
)

audioTrackEnum = (
    "1/0 (Mono)"   |
    "Dual mono"    |
    "2/0 (Stereo)" |
    "5.1 Surround"
)

printFormatElement =
  element format {
    element pod { xsd:boolean } &
    element width { measurementString } &
    element height { measurementString } &
    element scale { xsd:string { pattern = "[1-9][0-9]{1,3}%" } } &
    element orientation { printOrientationEnum } &
    element color { printColorEnum } &
    element fonts { printFormatFontElement* }
  }

printOrientationEnum = (
  "portrait" |
  "landscape"
)

printColorEnum = (
  "CMYK" |
  "RGB"
)

printFormatFontElement =
  element font {
    attribute type { printFontEnum },
    text
  }

printFontEnum = (
  "OpenType" |
  "Other" |
  "Bitmap" |
  "TrueType" |
  "Type1"
)

videoFormatElement =
  element format {
    element container {"MP4"} &
      videoFormatVideoStream &
      videoFormatAudioStream? &
      videoFormatSubtitleStream?
    }

videoFormatVideoStream =
  element videoStream {
      element codec { xsd:string } &
      element bitRate { xsd:positiveInteger } &
      element frameRate { xsd:decimal } &
      element screenResolution { xsd:string {pattern="[1-9][0-9]{0,3}x[1-9][0-9]{0,3}"} }
  }

videoFormatAudioStream =
  element audioStream { audioSubelements }

videoFormatSubtitleStream = element subtitleStream { empty }

brailleFormatElement =
  element format {
    element contracted { xsd:boolean } &
    element libLouisConfig { xsd:string }
  }

# format text (lax)

measurementString = text

percentageString = text

# names

namesElement =
  element names { namesName* }

namesName =
  element name {
    attribute id { nameIdString } &
    element long { lenGe2Le255String }? &
    element short { lenGe2Le255String } &
    element abbr { lenGe2Le255String }?
  }

# name text (lax)

nameIdString = text

# manifest

nonTranslationManifestElement =
  element manifest { (nonTranslationManifestContainer | nonTranslationManifestResource)+ }

translationManifestElement =
  element manifest { (translationManifestContainer | translationManifestResource)+ }

nonTranslationManifestContainer =
  element container {
    attribute uri { xsd:anyURI },
    (nonTranslationManifestContainer | nonTranslationManifestResource)+
  }

nonTranslationManifestResource =
  element resource {
    commonManifestResourceAtts
  }

translationManifestContainer =
  element container {
    attribute uri { xsd:anyURI },
    (translationManifestContainer | translationManifestResource)+
  }

translationManifestResource =
  element resource {
    commonManifestResourceAtts &
    attribute progress { xsd:positiveInteger { maxInclusive = "999" } }?
  }

commonManifestResourceAtts = (
  attribute uri { xsd:anyURI},
  attribute size { xsd:integer },
  attribute checksum { s3Checksum }?,
  attribute mimeType { mimeTypeString }
)

# manifest text (lax)

s3Checksum = text

mimeTypeString = text

# source

translationSourceElement =
  element source {
    empty |
    ( element canonicalContent { canonicalContentBook+} & (sourceStructureDivision | sourceStructureContent)+ )
  }

sourceStructureDivision =
  element division {
    attribute name {nameIdString},
    attribute role {roleId}?,
    (sourceStructureDivision | sourceStructureContent)+
  }

sourceStructureContent =
  element content {
    attribute name {nameIdString} &
    attribute src {srcPathString} &
    attribute role {roleId}?
  }

# source text (lax)

srcPathString = text

# publications

publicationsElement = # DCMI: tableOfContents
  element publications { publicationElement* }

publicationElement =
  element publication {
  attribute id { xsd:string { pattern = "[A-Za-z][A-Za-z0-9_\-]{0,31}" } },
  attribute default { xsd:boolean }?,
  publicationChildElements
  }

publicationChildElements = (
  element name { lenGe2String }? &
  element nameLocal { lenGe2String }? &
  element abbreviation { lenGe2String }? &
  element abbreviationLocal { lenGe2String }? &
  element description { lenGe2String }? &
  element descriptionLocal { lenGe2String }? &
  publicationCountriesElement? &
  element scope { scopeEnum }? &
  canonSpecElement? &
  element canonicalContent { canonicalContentBook+} &
  element structure { (publicationStructureDivision | publicationStructureContent)+ }
)

publicationCountriesElement = element countries { countryElement+ }

canonicalContentBook =
  element book {
    attribute code { canonicalBookIdEnum }
  }

publicationStructureDivision =
  element division {
    attribute name {nameIdString},
    attribute role {roleId}?,
    (publicationStructureDivision | publicationStructureContent)+
  }

publicationStructureContent =
  element content {
    attribute name {nameIdString} &
    attribute src {srcPathString} &
    attribute role {roleId}?
  }

# publications text

roleId = text

canonicalBookIdEnum = text

nonCanonicalBookIdEnum = text

# copyright

copyrightElement =
  element copyright {
    copyrightFullStatementElement &
    copyrightShortStatementElement?
  }

copyrightFullStatementElement =
  element fullStatement { statementContent+ }

copyrightShortStatementElement =
  element shortStatement { statementContent+ }

statementContent = htmlStatementContent | plainStatementContent

htmlStatementContent =
  element statementContent {
    attribute contentType { "xhtml" },
    simplifiedHtml+
  }

plainStatementContent =
  element statementContent {
    attribute contentType { "plain" },
    text
  }

# html

simplifiedHtml = (
    shP |
    shH1 |
    shH2 |
    shH3 |
    shUl |
    shOl |
    shBlockquote |
    shHtmlCharMarkup
)

shP = element p { nonEmptyString* & shHtmlCharMarkup* }

shH1 = element h1 { nonEmptyString* & shHtmlCharMarkup* }

shH2 = element h2 { nonEmptyString* & shHtmlCharMarkup* }

shH3 = element h3 { nonEmptyString* & shHtmlCharMarkup* }

shOl = element ol { shLi+ }

shUl = element ul { shLi+ }

shLi = element li { nonEmptyString* & shHtmlCharMarkup* }

shBlockquote = element blockquote { nonEmptyString* & shHtmlCharMarkup* }

shHtmlCharMarkup = (
  shA |
  shImg |
  shBr |
  shStrong |
  shB |
  shEm |
  shI
)

shA =
  element a {
    attribute href { xsd:anyURI },
    (nonEmptyString* & shHtmlCharMarkup* )
  }

shImg =
  element img {
    attribute src { xsd:anyURI },
    attribute alt { lenGe1String }
  }

shBr = element br { empty }

shStrong = element strong { nonEmptyString* & shHtmlCharMarkup* }

shB = element b { nonEmptyString* & shHtmlCharMarkup* }

shEm = element em { nonEmptyString* & shHtmlCharMarkup* }

shI = element i { nonEmptyString* & shHtmlCharMarkup* }

# promotion

promotionElement =
  element promotion {
    element promoVersionInfo {
      attribute contentType { "xhtml" },
      simplifiedHtml+
    }
  }

# archive_status

archiveStatusElement =
  element archiveStatus {
    element bundleCreatorName {lenGe2String}? &
    element archivistName { lenGe2String } &
    element dateArchived { xsd:dateTime | "null" } &
    element dateUpdated { xsd:dateTime | "null" } &
    element comments { lenLe255String }
  }

